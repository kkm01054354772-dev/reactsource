react : Node.js 기반

npm: 패키지 설치 도구(node.js 설치 시 안에 포함)

npm create vite@latest => 단계 확인

npm create vite@latest 프로젝트명 -- --template react => jsx 기반으로 프로젝트 생성
(npm create vite@latest begin -- --template react)


jsx(javascript xml) or tsx(typescript xml)

react:
 node.js 기반에서 react 모듈 설치 후 개발 가능
  npx create-react-app 프로젝트명

 컴포넌트 단위 개발 => 수많은 tsx(jsx) 생성
  브라우저 해석 : html, js, css만 가능 => tsx(jsx)를 모아서 html, js, css로 변환 

vite: 프론트엔드 개발도구
 - CRA(create-react-app)보다 빠른 속도 제공
  **- npm create vite@latest
    - TypeScript : Babel 기반 트랜스파일링
    **- TypeScript + SWC : SWC 기반 트랜스파일링(빠름)

VSCode 확장프로그램
 - Tailwind CSS IntelliSense
    => vscode에서 클래스 자동 완성
 - Tailwind Docs
 - Simple React Snippets : react 자동 완성

VSCode 설정
 - emmet (태그 자동완성 => html 페이지)
    => jsx, tsx 태그 자동완성 처리
  
lint : 문법검사
eslint : javascript 문법 검사

package.json => 현재 프로젝트 환경설정 (= build.gradle)
  - dependencies : 배포 시 필요한 패키지
  - devDependencies : 개발 시 필요한 패키지

실행 명령어
**npm run dev : 개발용 (작성코드를 실시간으로 확인)
npm run build : dist 폴더 생성 / 서버에 올려 사용자들에게 웹페이지로 서비스될 코드 컴파일
npm run lint : 문법 확인
npm run preview : 프로젝트 배포 전 테스트 단계



=====================================================================
프로젝트 생성단계
1. npm create vite@latest

2. cd 프로젝트폴더

3. npm i -D tailwindcss @tailwindcss/vite prettier-plugin-tailwindcss
    - prettier-plugin-tailwindcss : prettier(포맷터) - 자동정렬
      => tailwind 클래스 이름 자동정렬(공식 권장 순서)

  아래 설치 (선택사항)
   npm install react-icons --save
   npm install axios (필수)
   npm install react-router-dom (필수)
   npm install @reduxjs/toolkit react-redux

4. eslint.config.js에 추가
    -  rules: {
      "@typescript-eslint/no-unused-vars": "warn",
      "no-unused-vars": "off",
    },

5. vite.config.ts 수정 (tailwind) 
    - import tailwindcss from "@tailwindcss/vite"
    - // https://vite.dev/config/
      export default defineConfig({
      plugins: [react(), tailwindcss()],
      });

6. index.css 다 날리고 추가
    - @import "tailwindcss"

7. .prettierrc 생성
    - `{
      "plugins": ["prettier-plugin-tailwindcss"],
      "singleQuote": true
      }`

=====================================================================

React 특징
  - 컴퍼넌트 단위 개발
    => 클래스, 함수형(주로 사용)
    => 코드 재사용성, 유지 보수에 메리트
    => 관심사 분리를 통한 개발 효율성 증대


컴퍼넌트 작성
  - 함수 컴퍼넌트 작성
    return (
      태그 작성
      {자바스크립트 코드}
    )

- props : 컴퍼넌트 간 데이터를 공유
  <App name {name} age = {age} /> 
- children : 컴퍼넌트 태그 사이의 내용
- ** state : 컴퍼넌트 내부에서 변경될 수 있는 값


- 디자인
  (1) *.css => import 시켜서 사용
  (2) 자바스크립트 객체 => 인라인 방식
  (3) 태그 안에 사용 => (ex) {{color:'red', fontSize:25}}
  (4) CSS Module: 기존의 css 클래스명을 중복되지 않게 작성 가능
      => 파일이름_클래스명_해시값 형태로 자동으로 만들어 버림



Hook : 여러 컴퍼넌트에서 비슷한 기능을 공유할 경우 다른 훅을 사용할 수 있음, React 전용함수
- useState() : 렌더링(화면)과 관련 
               부모 렌더링(부모의 state 변경)시 자식도 렌더링 같이 발생
               자식의 state 변경할 때는 자식만 렌더링
- useRef() : 렌더링과는 별개로 변수를 사용하거나 DOM 요소에 직접 접근할 때 사용
           렌더링될 때 값이 초기화되지 않는다.
- useEffect() : React 컴퍼넌트의 생명주기에 맞춰 어떠한 작업 수행 시 사용
              - 1. Mounting : DOM이 생성되고 웹 브라우저 상에 나타나는 상황 (컴퍼넌트의 첫 렌더링 시점)
              - 2. Unmounting : 마운트 반대과정 (컴퍼넌트를 DOM에서 제거하는 시점)
              - 3. Updating : Props 변경 / State 변경 / 부모 컴퍼넌트가 리렌더링 될 때
- useReducer() : state를 한꺼번에 관리
               프로젝트의 상태 로직이 복잡할 경우 사용
- useMemo() : 시간이 많이 걸리는 함수, 굳이 리렌더링 되지 않아도 되는 컴퍼넌트에 적용
- useCallback() : 자식에게 내려가는 함수가 많고, 렌더링 비용이 클 때
- useContext()
    useReducer() : 상태를 어떻게 바꿀 것인지 관리
    useContext() : 상태를 어디서든 쓰게 만들 때 사용
    ==> useReducer() + useContext() => 상태 처리 라이브러리 redux 
  


라우팅 : 사용자가 요청한 URL에 따라 알맞은 페이지 보여주기
        리액트에서 라우팅 사용
        (1) 라이브러리 사용 : react-router-dom
        
        링크
        <Nav to={'/register'}>register</Nav>
        active 개념 적용
        <NavLink to={'/register'}>register</NavLink>

        const navigate = useNavigate() : () => navgiate();
        const loaction = useLocation() : 경로 추출 pathname/search/hash/state/key
        state : 페이지 이동시 임의로 넣을 수 있는 값
        path:'profile/:id'
        const {id} = useParams() : 동적인 주소 가져올 때
        const [searchParams] = useSearchParams() : ?뒤에 있는 값 가져올 때


        (2) Next.js 사용


중첩라우트
/account/login
/account/register